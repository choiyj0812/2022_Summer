const float xy_pos[480][2] = {
66.268 , 82.377,
66.527 , 82.217,
66.796 , 82.073,
67.072 , 81.946,
67.356 , 81.836,
67.647 , 81.743,
67.942 , 81.669,
68.241 , 81.613,
68.544 , 81.576,
68.848 , 81.557,
131.152, 81.557,
131.456, 81.576,
131.759, 81.613,
132.058, 81.669,
132.353, 81.743,
132.644, 81.836,
132.928, 81.946,
133.204, 82.073,
133.473, 82.217,
133.732, 82.377,
133.980, 82.553,
134.218, 82.744,
134.443, 82.950,
134.655, 83.168,
134.853, 83.400,
135.036, 83.643,
135.205, 83.897,
135.357, 84.160,
135.493, 84.433,
135.611, 84.714,
135.713, 85.001,
135.796, 85.294,
135.861, 85.591,
135.908, 85.892,
135.936, 86.196,
135.945, 86.500,
135.936, 86.804,
135.908, 87.108,
135.861, 87.409,
135.796, 87.706,
135.713, 87.999,
135.611, 88.286,
135.493, 88.567,
135.357, 88.840,
135.205, 89.103,
135.036, 89.357,
134.853, 89.600,
134.664, 89.821,
134.225, 90.251,
103.227, 117.248,
102.980, 117.446,
102.732, 117.622,
102.473, 117.783,
102.204, 117.927,
101.928, 118.054,
101.644, 118.164,
101.353, 118.257,
101.058, 118.331,
100.759, 118.387,
100.456, 118.424,
100.152, 118.443,
99.848 , 118.443,
99.544 , 118.424,
99.241 , 118.387,
98.942 , 118.331,
98.647 , 118.257,
98.356 , 118.164,
98.072 , 118.054,
97.796 , 117.927,
97.527 , 117.783,
97.268 , 117.622,
97.021 , 117.447,
96.737 , 117.217,
65.775 , 90.251,
65.336 , 89.821,
65.147 , 89.600,
64.964 , 89.357,
64.795 , 89.103,
64.643 , 88.840,
64.507 , 88.567,
64.389 , 88.286,
64.287 , 87.999,
64.204 , 87.706,
64.139 , 87.409,
64.092 , 87.108,
64.064 , 86.804,
64.055 , 86.500,
64.064 , 86.196,
64.092 , 85.892,
64.139 , 85.591,
64.204 , 85.294,
64.287 , 85.001,
64.389 , 84.714,
64.507 , 84.433,
64.643 , 84.160,
64.795 , 83.897,
64.964 , 83.643,
65.147 , 83.400,
65.345 , 83.168,
65.557 , 82.950,
65.782 , 82.745,
66.020 , 82.553,
65.586 , 81.979,
65.870 , 81.777,
66.167 , 81.593,
66.475 , 81.428,
66.792 , 81.282,
67.117 , 81.156,
67.449 , 81.051,
67.788 , 80.965,
68.131 , 80.901,
68.477 , 80.858,
68.826 , 80.837,
131.174, 80.837,
131.523, 80.858,
131.869, 80.901,
132.212, 80.965,
132.551, 81.051,
132.883, 81.156,
133.208, 81.282,
133.525, 81.428,
133.833, 81.593,
134.130, 81.777,
134.414, 81.979,
134.686, 82.197,
134.944, 82.433,
135.187, 82.683,
135.414, 82.948,
135.624, 83.227,
135.817, 83.517,
135.992, 83.820,
136.147, 84.132,
136.283, 84.453,
136.399, 84.782,
136.495, 85.118,
136.569, 85.459,
136.623, 85.804,
136.655, 86.151,
136.666, 86.500,
136.655, 86.849,
136.623, 87.196,
136.569, 87.541,
136.495, 87.882,
136.399, 88.218,
136.283, 88.547,
136.147, 88.868,
135.992, 89.180,
135.817, 89.483,
135.624, 89.773,
135.414, 90.052,
135.190, 90.313,
134.714, 90.780,
103.689, 117.800,
103.414, 118.021,
103.130, 118.223,
102.833, 118.407,
102.525, 118.572,
102.208, 118.718,
101.883, 118.844,
101.551, 118.949,
101.212, 119.035,
100.869, 119.099,
100.523, 119.142,
100.174, 119.163,
99.826 , 119.163,
99.477 , 119.142,
99.131 , 119.099,
98.788 , 119.035,
98.449 , 118.949,
98.117 , 118.844,
97.792 , 118.718,
97.475 , 118.572,
97.167 , 118.407,
96.870 , 118.223,
96.586 , 118.022,
96.274 , 117.769,
65.286 , 90.780,
64.810 , 90.313,
64.586 , 90.052,
64.376 , 89.773,
64.183 , 89.483,
64.008 , 89.180,
63.853 , 88.868,
63.717 , 88.547,
63.601 , 88.218,
63.505 , 87.882,
63.431 , 87.541,
63.377 , 87.196,
63.345 , 86.849,
63.334 , 86.500,
63.345 , 86.151,
63.377 , 85.804,
63.431 , 85.459,
63.505 , 85.118,
63.601 , 84.782,
63.717 , 84.453,
63.853 , 84.132,
64.008 , 83.820,
64.183 , 83.517,
64.376 , 83.227,
64.586 , 82.948,
64.813 , 82.683,
65.056 , 82.433,
65.314 , 82.197,
65.586 , 81.979,
68.037 , 85.535,
67.847 , 85.916,
67.731 , 86.326,
67.691 , 86.750,
67.731 , 87.174,
67.847 , 87.584,
68.037 , 87.965,
68.304 , 88.319,
68.710 , 88.667,
69.100 , 88.876,
69.506 , 89.005,
69.896 , 89.054,
130.104, 89.054,
130.494, 89.005,
130.900, 88.876,
131.275, 88.675,
131.607, 88.407,
131.884, 88.084,
132.097, 87.715,
132.239, 87.313,
132.304, 86.892,
132.291, 86.466,
132.196, 86.034,
131.973, 85.548,
131.706, 85.195,
131.391, 84.908,
131.029, 84.683,
130.632, 84.529,
130.246, 84.457,
130.071, 84.446,
69.896 , 84.446,
69.506 , 84.495,
69.100 , 84.624,
68.710 , 84.833,
68.304 , 85.181,
68.652 , 85.915,
68.521 , 86.177,
68.441 , 86.459,
68.414 , 86.750,
68.441 , 87.041,
68.521 , 87.323,
68.652 , 87.585,
68.832 , 87.823,
69.119 , 88.069,
69.382 , 88.210,
69.661 , 88.299,
69.940 , 88.334,
130.060, 88.334,
130.339, 88.299,
130.618, 88.210,
130.876, 88.072,
131.104, 87.888,
131.294, 87.666,
131.440, 87.413,
131.538, 87.137,
131.583, 86.848,
131.574, 86.555,
131.510, 86.264,
131.352, 85.920,
131.172, 85.682,
130.956, 85.485,
130.707, 85.331,
130.434, 85.225,
130.157, 85.173,
130.049, 85.166,
69.940 , 85.166,
69.661 , 85.201,
69.382 , 85.290,
69.119 , 85.431,
68.832 , 85.677,
92.904 , 101.189,
92.683 , 101.633,
92.489 , 102.090,
92.324 , 102.558,
92.189 , 103.035,
92.083 , 103.520,
92.006 , 104.010,
91.961 , 104.504,
91.945 , 105.000,
91.961 , 105.496,
92.006 , 105.990,
92.083 , 106.480,
92.189 , 106.965,
92.324 , 107.442,
92.489 , 107.910,
92.683 , 108.367,
92.904 , 108.811,
93.152 , 109.240,
93.426 , 109.654,
93.725 , 110.050,
94.048 , 110.426,
94.393 , 110.783,
94.760 , 111.117,
95.146 , 111.428,
95.551 , 111.714,
95.973 , 111.975,
96.410 , 112.210,
96.860 , 112.418,
97.323 , 112.597,
97.796 , 112.747,
98.277 , 112.868,
98.765 , 112.959,
99.257 , 113.020,
99.752 , 113.051,
100.248, 113.051,
100.743, 113.020,
101.235, 112.959,
101.723, 112.868,
102.204, 112.747,
102.677, 112.597,
103.140, 112.418,
103.590, 112.210,
104.027, 111.975,
104.449, 111.714,
104.854, 111.428,
105.240, 111.117,
105.607, 110.783,
105.952, 110.426,
106.275, 110.050,
106.574, 109.654,
106.848, 109.240,
107.096, 108.811,
107.317, 108.367,
107.511, 107.910,
107.676, 107.442,
107.811, 106.965,
107.917, 106.480,
107.994, 105.990,
108.039, 105.496,
108.055, 105.000,
108.039, 104.504,
107.994, 104.010,
107.917, 103.520,
107.811, 103.035,
107.676, 102.558,
107.511, 102.090,
107.317, 101.633,
107.096, 101.189,
106.848, 100.760,
106.574, 100.346,
106.275, 99.950,
105.952, 99.574,
105.607, 99.217,
105.240, 98.883,
104.854, 98.572,
104.449, 98.286,
104.027, 98.025,
103.590, 97.790,
103.140, 97.582,
102.677, 97.403,
102.204, 97.253,
101.723, 97.132,
101.235, 97.041,
100.743, 96.980,
100.248, 96.949,
99.752 , 96.949,
99.257 , 96.980,
98.765 , 97.041,
98.277 , 97.132,
97.796 , 97.253,
97.323 , 97.403,
96.860 , 97.582,
96.410 , 97.790,
95.973 , 98.025,
95.551 , 98.286,
95.146 , 98.572,
94.760 , 98.883,
94.393 , 99.217,
94.048 , 99.574,
93.725 , 99.950,
93.426 , 100.346,
93.152 , 100.760,
93.538 , 101.530,
93.337 , 101.935,
93.161 , 102.351,
93.011 , 102.777,
92.887 , 103.211,
92.791 , 103.652,
92.721 , 104.099,
92.680 , 104.548,
92.666 , 105.000,
92.680 , 105.451,
92.721 , 105.901,
92.791 , 106.348,
92.887 , 106.789,
93.011 , 107.223,
93.161 , 107.649,
93.337 , 108.065,
93.538 , 108.470,
93.764 , 108.861,
94.014 , 109.238,
94.286 , 109.598,
94.580 , 109.941,
94.894 , 110.265,
95.228 , 110.570,
95.580 , 110.853,
95.949 , 111.114,
96.333 , 111.352,
96.731 , 111.565,
97.141 , 111.754,
97.562 , 111.917,
97.993 , 112.054,
98.431 , 112.164,
98.875 , 112.247,
99.323 , 112.303,
99.774 , 112.331,
100.226, 112.331,
100.677, 112.303,
101.125, 112.247,
101.569, 112.164,
102.007, 112.054,
102.438, 111.917,
102.859, 111.754,
103.269, 111.565,
103.667, 111.352,
104.051, 111.114,
104.420, 110.853,
104.772, 110.570,
105.106, 110.265,
105.420, 109.941,
105.714, 109.598,
105.986, 109.238,
106.236, 108.861,
106.462, 108.470,
106.663, 108.065,
106.839, 107.649,
106.989, 107.223,
107.113, 106.789,
107.209, 106.348,
107.279, 105.901,
107.320, 105.451,
107.334, 105.000,
107.320, 104.548,
107.279, 104.099,
107.209, 103.652,
107.113, 103.211,
106.989, 102.777,
106.839, 102.351,
106.663, 101.935,
106.462, 101.530,
106.236, 101.139,
105.986, 100.762,
105.714, 100.402,
105.420, 100.059,
105.106, 99.735,
104.772, 99.430,
104.420, 99.147,
104.051, 98.886,
103.667, 98.648,
103.269, 98.435,
102.859, 98.246,
102.438, 98.083,
102.007, 97.946,
101.569, 97.836,
101.125, 97.752,
100.677, 97.697,
100.226, 97.669,
99.774 , 97.669,
99.323 , 97.697,
98.875 , 97.752,
98.431 , 97.836,
97.993 , 97.946,
97.562 , 98.083,
97.141 , 98.246,
96.731 , 98.435,
96.333 , 98.648,
95.949 , 98.886,
95.580 , 99.147,
95.228 , 99.430,
94.894 , 99.735,
94.580 , 100.059,
94.286 , 100.402,
94.014 , 100.762,
93.764 , 101.139,
93.764 , 101.139
}; 
//-------------------------------------------------
#include "gcode_sample_480.h"

#define beeper  27 //PA4
//----------------------------------
#define X_DIR   21 //PC5
#define X_STEP  15 //PD7
#define XY_EN   14 //PD6
//----------------------------------
#define Y_DIR   23 //PC7
#define Y_STEP  22 //PC6
//----------------------------------
#define X_STOP  18 //PC2
#define Y_STOP  19 //PC3
//----------------------------------
#define ENC_BTN 16 //PC0
#define ENC_A   10 //PD2
#define ENC_B   11 //PD3
//----------------------------------
#define CS      28 //CS/Chip Select - PA3
#define SCK     30 //SCK/Clock - PA1
#define MOSI    17 //MOSI/Master out Slave in - PC1
//==================================
void Setup_X(){
  pinMode(X_DIR, OUTPUT);
  pinMode(X_STEP, OUTPUT);
  pinMode(XY_EN, OUTPUT);
  digitalWrite(X_DIR, LOW);
  digitalWrite(X_STEP, LOW);
  digitalWrite(XY_EN, HIGH);
}

void Setup_Y(){
  pinMode(Y_DIR, OUTPUT);
  pinMode(Y_STEP, OUTPUT);
  pinMode(XY_EN, OUTPUT);
  digitalWrite(Y_DIR, LOW);
  digitalWrite(Y_STEP, LOW);
  digitalWrite(XY_EN, HIGH);
}

#define PI 3.14
unsigned long curr_millis = 0;
unsigned long prev_millis = 0;
unsigned long prev_millis_1 = 0;
unsigned long prev_millis_enc = 0;

unsigned long curr_micros = 0;
unsigned long prev_micros = 0;
unsigned long prev_micros_y = 0;
//----------------------------------
int count_buz = 0;
int duty = 1;
//----------------------------------
uint8_t toggle_motor_x = 0;
volatile int motor_count_x = 0;
volatile uint8_t motor_x_stop = 1;
uint8_t toggle_dir_X = 0;

uint8_t toggle_motor_y = 0;
volatile int motor_count_y = 0;
volatile uint8_t motor_y_stop = 1;
uint8_t toggle_dir_Y = 0;

uint8_t states = 0;
//----------------------------------
uint8_t flag_btn = 0;
enum{
  STATE_0 = 0,
  STATE_1,
  STATE_2,
  STATE_3
};
enum{
  MOTOR_X = 0,
  MOTOR_Y
};
enum{
  MOTOR_MOVE = 0,
  MOTOR_SPEED_SET
};
uint8_t state_enc = 0;
uint8_t select_motor = MOTOR_X;
uint8_t select_mode = MOTOR_MOVE;
unsigned int step_count_x = 400;
unsigned int step_count_y = 400;

int ocr1a_value = 400;  //200 ~ 1000 : 100us ~ 500us
int ocr3a_value = 400;

char *menu[6] = {
  "1. motor move   ",
  "2. step count   ",
  "3. motor speed  ",
  "4. go to home   ",
  "5. hoho         ",
  "6. haha         "
};

enum{
  MENU = 0,
  SUB_MENU
};
enum{
  SUB_MOTOR_MOVE = 0,
  SUB_MOTOR_STEP_COUNT,
  SUB_MOTOR_SPEED,
  SUB_HOME,
  SUB_HOHO
};

//------------------------------------

float prev_point_x = 0, prev_point_y = 0;
int pos_xy_index = 0;

int lcd_index = 0;

void setup() {
  Serial.begin(9600);
  //----------------------------------
  pinMode(beeper, OUTPUT);
  digitalWrite(beeper, LOW);
  //----------------------------------
  pinMode(X_STOP, INPUT);
  pinMode(Y_STOP, INPUT);
  //----------------------------------
  pinMode(ENC_BTN, INPUT);
  pinMode(ENC_A, INPUT);
  pinMode(ENC_B, INPUT);
  digitalWrite(ENC_BTN, HIGH);
  digitalWrite(ENC_A, HIGH);
  digitalWrite(ENC_B, HIGH);
  //----------------------------------
  pinMode(CS, OUTPUT);
  pinMode(SCK, OUTPUT);
  pinMode(MOSI, OUTPUT);
  //=======================================================
  //ENCODER BUTTON
  /*while(1){
    //----------------------------------
    func_btn_enc();
    //----------------------------------
    delay(10);
  }*/
  
  //=======================================================
  //Timer2
  /*TCCR2A = 0x00;  // Normal Mode
  TCCR2B = 0x03;  // 0x02 : 8분주, 0x03 : 32분주
  TCNT2 = 156;
  TIMSK2 = 0x01;  // 0x01 : Overflow Interrupt*/

  //=======================================================
  //Timer1
  /*TCCR1A = 0x00;
  TCCR1B = 0x02;  //0x02 : 8분주 = 0.5us
  TCCR1C = 0x00;
  TCNT1 = 65536 - 400;
  //400 : 400 * 0.5us => 200us마다 인터럽트 발생
  //65536 = 2^16
  TIMSK1 = 0x01;*/

  TCCR1A = 0x00;
  TCCR1B = 0x0A;  //0x02 : 8분주 = 0.5us
  TCCR1C = 0x00;
  TCNT1 = 0;
  OCR1A = ocr1a_value;
  TIMSK1 = 0x02;
  //0x01 : overflow interrupt, 0x02 : compare match interrupt A

  //Timer3
  TCCR3A = 0x00;
  TCCR3B = 0x0A;  //0x02 : 8분주 = 0.5us
  TCCR3C = 0x00;
  TCNT3 = 0;
  OCR3A = ocr3a_value;
  TIMSK3 = 0x02;
  //0x01 : overflow interrupt, 0x02 : compare match interrupt A
  
  //=======================================================
  Setup_X();
  Setup_Y();
  digitalWrite(X_DIR, LOW);
  digitalWrite(Y_DIR, LOW);
  digitalWrite(XY_EN, LOW);

  //digitalWrite(X_DIR, HIGH);
  //digitalWrite(Y_DIR, HIGH);

  //=======================================================
  digitalWrite(XY_EN, LOW);

  /*TCNT1 = 0;
  OCR1A = ocr1a_value;
  step_count_x = 4000;
  motor_x_stop = 0;

  TCNT3 = 0;
  OCR3A = ocr3a_value;
  step_count_y = 4000;
  motor_y_stop = 0;*/
  
  /*p2p_move(50,0);
  delay(3000);
  p2p_move(50,50);
  delay(3000);
  p2p_move(0,50);
  delay(3000);
  p2p_move(0,0);
  delay(3000);*/
  
  /*double pos_xy[4][2] = {{50, 0}, {50, 50}, {0, 50}, {0, 0}};
  for(int i=0;i<4;i++){
    p2p_move(pos_xy[i][0], pos_xy[i][1]);
    delay(3000);
  }*/

  /*double pos_xy[4][2] = {{50, 0}, {50, 50}, {0, 50}, {0, 0}};
  while(1){
    if(motor_x_stop == 1 && motor_y_stop == 1){
      p2p_move(pos_xy[pos_xy_index][0], pos_xy[pos_xy_index][1]);
      pos_xy_index++;
      if(pos_xy_index == 4) break;
    }
    delay(1);
  }*/
  /*while(1){
    if(motor_x_stop == 1 && motor_y_stop == 1){
      p2p_move(xy_pos[pos_xy_index][0], xy_pos[pos_xy_index][1]);
      pos_xy_index++;
      if(pos_xy_index == 480) break;
      //Serial.println(pos_xy_index);
    }
    //delay(1);
  }*/
  //=======================================================
  //LCD
  //명령어 배열
  uint8_t command_array[8] = {0x30, 0x30, 0x30, 0x38, 0x06, 0x0C, 0x80, 0x01};
  for(int i=0;i<8;i++){
    lcd_command_set(command_array[i]);
  }
  delay(2);

  lcd_index = 0;

  lcd_print_all_menu(lcd_index);
  /*lcd_set_cursor(0,0);
  lcd_set_string("haha");
  lcd_set_cursor(1,0);
  lcd_set_string("Hello World!");

  int count_lcd = 0;
  char buf[20];
  while(1){
    sprintf(buf, "%d", count_lcd++);
    lcd_set_cursor(2,0);
    lcd_set_string(buf);
    delay(1000);
  }*/
  //=======================================================
  //SWITCH
  
  while(1){
    /*if(digitalRead(X_STOP) == 1){
      motor_x_stop = 1;
    }
    if(digitalRead(Y_STOP) == 1){
      motor_y_stop = 1;
    }*/
    curr_millis = millis();
    //curr_micros = micros();

    if(curr_millis - prev_millis_enc > 10){
      prev_millis_enc = curr_millis;

      func_btn_enc();
    }
    
    /*if(curr_millis - prev_millis > 1000){
      prev_millis = curr_millis;
      Serial.println("1sec");
    }*/

    /*if(curr_millis - prev_millis_1 > 10){
      prev_millis_1 = curr_millis;
      duty++;
      if(duty == 99) duty = 1;
    }
    if(curr_micros - prev_micros > 100){
      count_buz++;
      if(count_buz == 100){
        count_buz = 0;
        digitalWrite(beeper, HIGH);
      }
      else if(count_buz == duty) digitalWrite(beeper, LOW);
    }*/

    //-------------------------------------

    /*if(curr_millis - prev_millis_1 > 3000){
      prev_millis_1 = curr_millis;

//      if(states == 0){
//        digitalWrite(X_DIR, LOW);
//        motor_x_stop = 0;
//        motor_y_stop = 1;
//      }
//      else if(states == 1){
//        digitalWrite(Y_DIR, LOW);
//        motor_x_stop = 1;
//        motor_y_stop = 0;
//      }
//      else if(states == 2){
//        digitalWrite(X_DIR, HIGH);
//        motor_x_stop = 0;
//        motor_y_stop = 1;
//      }
//      else{
//        digitalWrite(Y_DIR, HIGH);
//        motor_x_stop = 1;
//        motor_y_stop = 0;
//      }
//
//      states++;
//      if(states == 4) states = 0;

      //-------------------------------------
      
      if(toggle_dir_X == 0){
        toggle_dir_X = 1;
        digitalWrite(X_DIR, LOW);
        motor_x_stop = 0;
      }
      else{
        toggle_dir_X = 0;
        digitalWrite(X_DIR, HIGH);
        motor_x_stop = 0;
      }

      if(toggle_dir_Y == 0){
        toggle_dir_Y = 1;
        digitalWrite(Y_DIR, LOW);
        motor_y_stop = 0;
      }
      else{
        toggle_dir_Y = 0;
        digitalWrite(Y_DIR, HIGH);
        motor_y_stop = 0;
      }
    }*/

    /*if(motor_x_stop == 0){
      if(curr_micros - prev_micros > 200){
        prev_micros = curr_micros;
        if(toggle_motor_x == 0){
          toggle_motor_x = 1;
          digitalWrite(X_STEP, HIGH);
  
          motor_count_x++;
          if(motor_count_x == 400){
            motor_count_x = 0;
            motor_x_stop = 1;
          }
        }
        else{
          toggle_motor_x = 0;
          digitalWrite(X_STEP, LOW);
        }
      }
    }

    if(motor_y_stop == 0){
      if(curr_micros - prev_micros_y > 200){
        prev_micros_y = curr_micros;
        if(toggle_motor_y == 0){
          toggle_motor_y = 1;
          digitalWrite(Y_STEP, HIGH);
  
          motor_count_y++;
          if(motor_count_y == 400){
            motor_count_y = 0;
            motor_y_stop = 1;
          }
        }
        else{
          toggle_motor_y = 0;
          digitalWrite(Y_STEP, LOW);
        }
      }
    }*/
  }


  
  //=======================================================
  /*double radian = 0;
  double degree_1 = 60.0;
  double degree_to_radian = ((degree_1 / 360.0) * (2 * PI));
  double distance_b = 5 * cos(degree_to_radian);
  double distance_c = 5 * sin(degree_to_radian);
  Serial.println(distance_b);
  Serial.println(distance_c);
  
  while(1);*/
  //=======================================================
  /*Setup_X();
  Setup_Y();
  Active_X(true);
  Active_XY(false, true, 1, 2);
  Active_XY(false, false, 1, 2);*/
}

void loop() {
  
}

void lcd_print_all_menu(int index){
  if(index <= 2 && index >= 0){
    for(int i=0;i<4;i++){
      lcd_set_cursor(i,0);
      lcd_set_string(menu[i + index]);
    }
  }
}

void lcd_set_cursor(unsigned int line_num, int col){
  if(line_num == 0){
    if(col < 8){
      lcd_command_set(0x80 + col);
    }
  }
  else if(line_num == 1){
    if(col < 8){
      lcd_command_set(0x90 + col);
    }
  }
  else if(line_num == 2){
    if(col < 8){
      lcd_command_set(0x88 + col);
    }
  }
  else if(line_num == 3){
    if(col < 8){
      lcd_command_set(0x98 + col);
    }
  }
}

void lcd_set_string(char *str){
  int str_len = strlen(str);

  for(int i=0;i<str_len;i++){
    lcd_data_set(str[i]); // = lcd_data_set(*(str + i));
  }
}

void lcd_command_set(uint8_t command){
  digitalWrite(CS, HIGH);
  uint8_t upper_byte = command & 0xF0;
  uint8_t lower_byte = (command & 0x0F) << 4;
  shift_8bit(0xF8); //0xF8 : command
  shift_8bit(upper_byte);
  shift_8bit(lower_byte);
  digitalWrite(CS, LOW);
  delayMicroseconds(50);
}

void lcd_data_set(uint8_t lcd_data){
  digitalWrite(CS, HIGH);
  uint8_t upper_byte = lcd_data & 0xF0;
  uint8_t lower_byte = (lcd_data & 0x0F) << 4;
  shift_8bit(0xFA); //0xFA : data
  shift_8bit(upper_byte);
  shift_8bit(lower_byte);
  digitalWrite(CS, LOW);
  delayMicroseconds(50);
}

void shift_8bit(uint8_t shift_data){
  for(int i=0;i<8;i++){
    if(shift_data & (0x80 >> i)){
      digitalWrite(MOSI, HIGH);
    }
    else{
      digitalWrite(MOSI, LOW);
    }
    digitalWrite(SCK, HIGH);
    digitalWrite(SCK, LOW);
  }
}

void p2p_move(float dest_x, float dest_y){  //dest_x(mm), dest_y(mm)
  float diff_x = dest_x - prev_point_x;
  float diff_y = dest_y - prev_point_y;
  /*Serial.print("diff_x : ");
  Serial.println(diff_x);
  Serial.print("diff_y : ");
  Serial.println(diff_y);*/
  
  step_count_x = 0;
  step_count_y = 0;
  OCR1A = 400;
  OCR3A = 400;

  //Serial.print("X_DIR : ");
  if(diff_x > 0){
    digitalWrite(X_DIR, LOW);
    //Serial.print("+, ");
  }
  //else if(diff_x == 0) Serial.print("0, ");
  else{
    digitalWrite(X_DIR, HIGH);
    //Serial.print("-, ");
  }
  
  //Serial.print("Y_DIR : ");
  if(diff_y > 0){
    digitalWrite(Y_DIR, LOW);
    //Serial.println("+");
  }
  //else if(diff_y == 0) Serial.println("0, ");
  else{
    digitalWrite(Y_DIR, HIGH);
    //Serial.println("-");
  }
  //------------------------------------------
  if(diff_x == 0 && diff_y == 0) return;
  else if(diff_x != 0 && diff_y != 0){
    ocr1a_value = 400;                              // x
    ocr3a_value = (int)round(abs((400 * (diff_x / diff_y)))); // y

    step_count_x = (int)round(abs((diff_x * 80))); //80 = 1 / 0.0125(mm)
    step_count_y = (int)round(abs((diff_y * 80)));

    TCNT1 = 0;
    TCNT3 = 0;

    OCR1A = ocr1a_value;
    OCR3A = ocr3a_value;

    motor_x_stop = 0;
    motor_y_stop = 0;
  }
  else if(diff_y != 0){
    ocr3a_value = 400;
    step_count_y = (int)round(abs((diff_y * 80)));
    TCNT3 = 0;
    OCR3A = ocr3a_value;
    motor_x_stop = 1;
    motor_y_stop = 0;
  }
  else if(diff_x != 0){
    ocr1a_value = 400;
    step_count_x = (int)round(abs((diff_x * 80)));
    TCNT1 = 0;
    OCR1A = ocr1a_value;
    motor_x_stop = 0;
    motor_y_stop = 1;
  }
  /*Serial.print("step_count_x : ");
  Serial.println(step_count_x);
  Serial.print("step_count_y : ");
  Serial.println(step_count_y);*/
  
  //------------------------------------------
  prev_point_x = dest_x;
  prev_point_y = dest_y;
}

uint8_t toggle_btn = 0;
int menu_index = 0;
int btn_select = 0;
int which_menu = 0;

void func_btn_enc(){
  //int enc_btn = digitalRead(ENC_BTN);
  uint8_t pin_c = PINC;
  int enc_btn = (pin_c & 0x01) ? 1 : 0;
  // pullup -> 0:push
  if(enc_btn == 0 && flag_btn == 0){
    flag_btn = 1;
    //Serial.println("push");

    /*if(toggle_btn == 0){
      toggle_btn = 1;
      select_motor = MOTOR_X;
      Serial.println("MOTOR_X");
    }
    else if(toggle_btn == 1){
      toggle_btn = 0;
      select_motor = MOTOR_Y;
      Serial.println("MOTOR_Y");
    }*/
    //-----------------------------
    /*if(toggle_btn == 0){
      toggle_btn = 1;
      select_mode = MOTOR_MOVE;
      Serial.println("now mode : MOTOR_MOVE");
    }
    else if(toggle_btn == 1){
      toggle_btn = 0;
      select_mode = MOTOR_SPEED_SET;
      Serial.println("MOTOR_SPEED_SET");
    }*/
    //-------------------------------------------
    if(which_menu == MENU){
      btn_select = menu_index;
      which_menu = SUB_MENU;
      Serial.println("Select this SUB_MENU!");

      if(btn_select == SUB_HOME){
        step_count_x = 30000;
        digitalWrite(X_DIR, HIGH);
        motor_x_stop = 0;

        step_count_y = 30000;
        digitalWrite(Y_DIR, HIGH);
        motor_y_stop = 0;

        while(1){
          int x_stop = digitalRead(X_STOP);
          int y_stop = digitalRead(Y_STOP);
          Serial.println(x_stop);
          Serial.println(y_stop);
          if(x_stop == 1){
            motor_x_stop = 1;
          }
          if(y_stop == 1){
            motor_y_stop = 1;
          }
          if(motor_x_stop == 1 && motor_y_stop == 1){
            step_count_x = 400;
            step_count_y = 400;
            break;
          }
          delay(1);
        }
      }
    }
    else if(which_menu == SUB_MENU){
      which_menu = MENU;
      Serial.println("Return to MAIN_MENU!");
    }
  }
  else if(enc_btn == 1 && flag_btn == 1){
    flag_btn = 0;
    //Serial.println("pull");
  }
  //----------------------------------
  int enc_a = digitalRead(ENC_A);
  int enc_b = digitalRead(ENC_B);

  //Serial.print(enc_a);  Serial.print(' ');
  //Serial.println(enc_b);
  if(enc_a == 1 && enc_b == 1){
    state_enc = STATE_0;
  }
  else if(enc_a == 0 && enc_b == 1){
    if(state_enc == STATE_2){
      //Serial.println("Left");

      /*if(select_motor == MOTOR_X){
        digitalWrite(X_DIR, HIGH);
        motor_x_stop = 0;
      }
      else{
        digitalWrite(Y_DIR, HIGH);
        motor_y_stop = 0;
      }*/
      //------------------------------
      /*if(select_mode == MOTOR_MOVE){
        digitalWrite(X_DIR, HIGH);
        motor_x_stop = 0;
      }
      else if(select_mode == MOTOR_SPEED_SET){
//        step_count -= 100;
//        if(step_count < 200) step_count = 200;
//        Serial.println(step_count);
          //--------------------------------------
          TCNT1 = 0;
          ocr1a_value -= 100;
          if(ocr1a_value < 200) ocr1a_value = 200;
          OCR1A = ocr1a_value;
          Serial.println(ocr1a_value);
      }*/
      //------------------------------
      /*if(which_menu == MENU){
        menu_index--;
        if(menu_index < 0) menu_index = 4;
        Serial.println(menu[menu_index]);
      }
      else if(which_menu == SUB_MENU){
        if(btn_select == SUB_MOTOR_MOVE){
          digitalWrite(X_DIR, HIGH);
          motor_x_stop = 0;
        }
        else if(btn_select == SUB_MOTOR_STEP_COUNT){
          step_count_x -= 100;
          if(step_count_x < 200) step_count_x = 200;
          Serial.println(step_count_x);
        }
        else if(btn_select == SUB_MOTOR_SPEED){
          TCNT1 = 0;
          ocr1a_value -= 100;
          if(ocr1a_value < 200) ocr1a_value = 200;
          OCR1A = ocr1a_value;
          Serial.println(ocr1a_value);
        }
      }*/
      //------------------------------
      lcd_index--;
      if(lcd_index < 0) lcd_index = 0;
      lcd_print_all_menu(lcd_index);
    }
    state_enc = STATE_1;
  }
  else if(enc_a == 0 && enc_b == 0){
    if(state_enc == STATE_1){
      //Serial.println("Right");

      /*if(select_motor == MOTOR_X){
        digitalWrite(X_DIR, LOW);
        motor_x_stop = 0;
      }
      else{
        digitalWrite(Y_DIR, LOW);
        motor_y_stop = 0;
      }*/
      //------------------------------
      /*if(select_mode == MOTOR_MOVE){
        digitalWrite(X_DIR, LOW);
        motor_x_stop = 0;
      }
      else if(select_mode == MOTOR_SPEED_SET){
//        step_count += 100;
//        if(step_count > 4000) step_count = 4000;
//        Serial.println(step_count);
          //------------------------------------------
          TCNT1 = 0;
          ocr1a_value += 100;
          if(ocr1a_value > 4000) ocr1a_value = 4000;
          OCR1A = ocr1a_value;
          Serial.println(ocr1a_value);
      }*/
      //------------------------------
      /*if(which_menu == MENU){
        menu_index++;
        if(menu_index > 4) menu_index = 0;
        Serial.println(menu[menu_index]);
      }
      else if(which_menu == SUB_MENU){
        if(btn_select == SUB_MOTOR_MOVE){
          digitalWrite(X_DIR, LOW);
          motor_x_stop = 0;
        }
        else if(btn_select == SUB_MOTOR_STEP_COUNT){
          step_count_x += 100;
          if(step_count_x > 4000) step_count_x = 4000;
          Serial.println(step_count_x);
        }
        else if(btn_select == SUB_MOTOR_SPEED){
          TCNT1 = 0;
          ocr1a_value += 100;
          if(ocr1a_value > 4000) ocr1a_value = 4000;
          OCR1A = ocr1a_value;
          Serial.println(ocr1a_value);
        }
      }*/
      //------------------------------
      lcd_index++;
      if(lcd_index > 2) lcd_index = 2;
      lcd_print_all_menu(lcd_index);
    }
    state_enc = STATE_2;
  }
  else if(enc_a == 1 && enc_b == 0){
    state_enc = STATE_3;
  }
  //Serial.println(state_enc);
}

//SIGNAL(TIMER2_OVF_vect){
//SIGNAL(TIMER1_OVF_vect){
SIGNAL(TIMER1_COMPA_vect){
  //TCNT1 = 65536 - 400;
  
  if(motor_x_stop == 0){
    if(toggle_motor_x == 0){
      toggle_motor_x = 1;
      digitalWrite(X_STEP, HIGH);
  
      motor_count_x++;
      if(motor_count_x == step_count_x){
        motor_count_x = 0;
        motor_x_stop = 1;
      }
    }
    else{
      toggle_motor_x = 0;
      digitalWrite(X_STEP, LOW);
    }
  }
  /*else if(motor_x_stop + motor_y_stop == 2){
    digitalWrite(X_DIR, LOW);
    if(toggle_motor_x == 0){
      toggle_motor_x = 1;
      digitalWrite(X_STEP, HIGH);
  
      motor_count_x++;
      if(motor_count_x == 4000){
        motor_count_x = 0;
        motor_x_stop = 2;
      }
    }
    else{
      toggle_motor_x = 0;
      digitalWrite(X_STEP, LOW);
    }
  }*/
}

SIGNAL(TIMER3_COMPA_vect){
  //TCNT1 = 65536 - 400;
  
  if(motor_y_stop == 0){
    if(toggle_motor_y == 0){
      toggle_motor_y = 1;
      digitalWrite(Y_STEP, HIGH);
  
      motor_count_y++;
      if(motor_count_y == step_count_y){
        motor_count_y = 0;
        motor_y_stop = 1;
      }
    }
    else{
      toggle_motor_y = 0;
      digitalWrite(Y_STEP, LOW);
    }
  }
  /*else if(motor_x_stop + motor_y_stop == 2){
    digitalWrite(Y_DIR, LOW);
    if(toggle_motor_y == 0){
      toggle_motor_y = 1;
      digitalWrite(Y_STEP, HIGH);
  
      motor_count_y++;
      if(motor_count_y == 4000){
        motor_count_y = 0;
        motor_y_stop = 2;
      }
    }
    else{
      toggle_motor_y = 0;
      digitalWrite(Y_STEP, LOW);
    }
  }*/
}